// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float2 position;
    float2 velocity;
};

StructuredBuffer<Boid> in_boids;
RWStructuredBuffer<Boid> out_boids;
uint boid_count;

float centering_strength;
float separation_strength;
float match_velocity_strength;

[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Input
    float2 v1 = float2(0, 0),
              v2 = float2(0, 0),
              v3 = float2(0, 0);
    Boid boid = in_boids[id.x];

    // Loop through all other boids in HLSL
    for (uint i = 0; i < boid_count; i++)
    {
        if (i == id.x) continue;

        const Boid other = in_boids[i];
    
        // Rule 1: Boids try to fly towards the centre of mass of neighbouring boids.
        if (distance(boid.position, other.position) < 10) {
            v1 += other.position;
        }
        
        // Rule 2: Boids try to keep a small distance away from other objects (including other boids).
        if (distance(boid.position, other.position) < 5)
        {
            v2 = v2 - (other.position - boid.position);    
        }
    
        // Rule 3: Boids try to match velocity with near boids.
        if (distance(boid.position, other.position) < 10)
        {
            v3 += other.velocity;
        }
    }

    // Apply the three rules
    v1 = v1 / (boid_count - 1);
    v1 = (v1 - boid.position) / 100;
    v1 = v1 * centering_strength;

    v2 = v2 * separation_strength;
    
    v3 = v3 / (boid_count - 1);
    v3 = (v3 - boid.velocity) / 8;
    v3 = v3 * match_velocity_strength;
    
    // Apply updates
    boid.velocity += (v1 + v2 + v3);
    boid.position += boid.velocity;

    // Write out
    out_boids[id.x] = boid;
}
